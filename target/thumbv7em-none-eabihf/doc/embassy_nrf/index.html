<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Embassy nRF HAL"><title>embassy_nrf - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="embassy_nrf" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.1 (4eb161250 2025-03-15)" data-channel="1.85.1" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../embassy_nrf/index.html">embassy_<wbr>nrf</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#embassy-nrf-hal" title="Embassy nRF HAL">Embassy nRF HAL</a><ul><li><a href="#hardware-support" title="Hardware support">Hardware support</a></li><li><a href="#time-driver" title="Time driver">Time driver</a></li><li><a href="#embedded-hal" title="Embedded-hal">Embedded-hal</a></li><li><a href="#interoperability" title="Interoperability">Interoperability</a></li><li><a href="#easydma-considerations" title="EasyDMA considerations">EasyDMA considerations</a></li><li><a href="#feature-flags" title="Feature flags">Feature flags</a></li></ul></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#attributes" title="Attribute Macros">Attribute Macros</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>embassy_nrf</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/embassy_nrf/lib.rs.html#1-576">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="embassy-nrf-hal"><a class="doc-anchor" href="#embassy-nrf-hal">§</a>Embassy nRF HAL</h2>
<p>HALs implement safe, idiomatic Rust APIs to use the hardware capabilities, so raw register manipulation is not needed.</p>
<p>The Embassy nRF HAL targets the Nordic Semiconductor nRF family of hardware. The HAL implements both blocking and async APIs
for many peripherals. The benefit of using the async APIs is that the HAL takes care of waiting for peripherals to
complete operations in low power mode and handling interrupts, so that applications can focus on more important matters.</p>
<p>NOTE: The Embassy HALs can be used both for non-async and async operations. For async, you can choose which runtime you want to use.</p>
<p>For a complete list of available peripherals and features, see the <a href="https://docs.embassy.dev/embassy-nrf">embassy-nrf documentation</a>.</p>
<h3 id="hardware-support"><a class="doc-anchor" href="#hardware-support">§</a>Hardware support</h3>
<p>The <code>embassy-nrf</code> HAL supports most variants of the nRF family:</p>
<ul>
<li>nRF52 (<a href="https://github.com/embassy-rs/embassy/tree/main/examples/nrf52840">examples</a>)</li>
<li>nRF53 (<a href="https://github.com/embassy-rs/embassy/tree/main/examples/nrf5340">examples</a>)</li>
<li>nRF91 (<a href="https://github.com/embassy-rs/embassy/tree/main/examples/nrf9160">examples</a>)</li>
</ul>
<p>Most peripherals are supported. To check what’s available, make sure to pick the MCU you’re targeting in the top menu in the <a href="https://docs.embassy.dev/embassy-nrf">documentation</a>.</p>
<p>For MCUs with TrustZone support, both Secure (S) and Non-Secure (NS) modes are supported. Running in Secure mode
allows running Rust code without a SPM or TF-M binary, saving flash space and simplifying development.</p>
<h3 id="time-driver"><a class="doc-anchor" href="#time-driver">§</a>Time driver</h3>
<p>If the <code>time-driver-rtc1</code> feature is enabled, the HAL uses the RTC peripheral as a global time driver for <a href="https://crates.io/crates/embassy-time">embassy-time</a>, with a tick rate of 32768 Hz.</p>
<h3 id="embedded-hal"><a class="doc-anchor" href="#embedded-hal">§</a>Embedded-hal</h3>
<p>The <code>embassy-nrf</code> HAL implements the traits from <a href="https://crates.io/crates/embedded-hal">embedded-hal</a> (v0.2 and 1.0) and <a href="https://crates.io/crates/embedded-hal-async">embedded-hal-async</a>, as well as <a href="https://crates.io/crates/embedded-io">embedded-io</a> and <a href="https://crates.io/crates/embedded-io-async">embedded-io-async</a>.</p>
<h3 id="interoperability"><a class="doc-anchor" href="#interoperability">§</a>Interoperability</h3>
<p>This crate can run on any executor.</p>
<p>Optionally, some features requiring <a href="https://crates.io/crates/embassy-time"><code>embassy-time</code></a> can be activated with the <code>time</code> feature. If you enable it,
you must link an <code>embassy-time</code> driver in your project.</p>
<h3 id="easydma-considerations"><a class="doc-anchor" href="#easydma-considerations">§</a>EasyDMA considerations</h3>
<p>On nRF chips, peripherals can use the so called EasyDMA feature to offload the task of interacting
with peripherals. It takes care of sending/receiving data over a variety of bus protocols (TWI/I2C, UART, SPI).
However, EasyDMA requires the buffers used to transmit and receive data to reside in RAM. Unfortunately, Rust
slices will not always do so. The following example using the SPI peripheral shows a common situation where this might happen:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// As we pass a slice to the function whose contents will not ever change,
// the compiler writes it into the flash and thus the pointer to it will
// reference static memory. Since EasyDMA requires slices to reside in RAM,
// this function call will fail.
</span><span class="kw">let </span>result = spim.write_from_ram(<span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="macro">assert_eq!</span>(result, <span class="prelude-val">Err</span>(Error::BufferNotInRAM));

<span class="comment">// The data is still static and located in flash. However, since we are assigning
// it to a variable, the compiler will load it into memory. Passing a reference to the
// variable will yield a pointer that references dynamic memory, thus making EasyDMA happy.
// This function call succeeds.
</span><span class="kw">let </span>data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>result = spim.write_from_ram(<span class="kw-2">&amp;</span>data);
<span class="macro">assert!</span>(result.is_ok());</code></pre></div>
<p>Each peripheral struct which uses EasyDMA (<a href="spim/struct.Spim.html" title="struct embassy_nrf::spim::Spim"><code>Spim</code></a>, <a href="uarte/struct.Uarte.html" title="struct embassy_nrf::uarte::Uarte"><code>Uarte</code></a>, <a href="twim/struct.Twim.html" title="struct embassy_nrf::twim::Twim"><code>Twim</code></a>) has two variants of their mutating functions:</p>
<ul>
<li>Functions with the suffix (e.g. <a href="spim/struct.Spim.html#method.write_from_ram" title="method embassy_nrf::spim::Spim::write_from_ram"><code>write_from_ram</code></a>, <a href="spim/struct.Spim.html#method.transfer_from_ram" title="method embassy_nrf::spim::Spim::transfer_from_ram"><code>transfer_from_ram</code></a>) will return an error if the passed slice does not reside in RAM.</li>
<li>Functions without the suffix (e.g. <a href="spim/struct.Spim.html#method.write" title="method embassy_nrf::spim::Spim::write"><code>write</code></a>, <a href="spim/struct.Spim.html#method.transfer" title="method embassy_nrf::spim::Spim::transfer"><code>transfer</code></a>) will check whether the data is in RAM and copy it into memory prior to transmission.</li>
</ul>
<p>Since copying incurs a overhead, you are given the option to choose from <code>_from_ram</code> variants which will
fail and notify you, or the more convenient versions without the suffix which are potentially a little bit
more inefficient. Be aware that this overhead is not only in terms of instruction count but also in terms of memory usage
as the methods without the suffix will be allocating a statically sized buffer (up to 512 bytes for the nRF52840).</p>
<p>Note that the methods that read data like <a href="spim/struct.Spim.html#method.read" title="method embassy_nrf::spim::Spim::read"><code>read</code></a> and <a href="spim/struct.Spim.html#method.transfer_in_place" title="method embassy_nrf::spim::Spim::transfer_in_place"><code>transfer_in_place</code></a> do not have the corresponding <code>_from_ram</code> variants as
mutable slices always reside in RAM.</p>
<h3 id="feature-flags"><a class="doc-anchor" href="#feature-flags">§</a>Feature flags</h3>
<ul>
<li><span class="stab portability"><code>rt</code></span> <em>(enabled by default)</em> —  Cortex-M runtime (enabled by default)</li>
<li><span class="stab portability"><code>time</code></span> —  Enable features requiring <code>embassy-time</code></li>
<li><span class="stab portability"><code>defmt</code></span> —  Enable defmt</li>
<li><span class="stab portability"><code>unstable-pac</code></span> —  Reexport the PAC for the currently enabled chip at <code>embassy_nrf::pac</code> (unstable)</li>
<li><span class="stab portability"><code>gpiote</code></span> —  Enable GPIO tasks and events</li>
<li><span class="stab portability"><code>time-driver-rtc1</code></span> —  Use RTC1 as the time driver for <code>embassy-time</code>, with a tick rate of 32.768khz</li>
<li><span class="stab portability"><code>nfc-pins-as-gpio</code></span> —  Allow using the NFC pins as regular GPIO pins (P0_09/P0_10 on nRF52, P0_02/P0_03 on nRF53)</li>
<li><span class="stab portability"><code>reset-pin-as-gpio</code></span> —  Allow using the RST pin as a regular GPIO pin.
<ul>
<li>nRF52805, nRF52810, nRF52811, nRF52832: P0_21</li>
<li>nRF52820, nRF52833, nRF52840: P0_18</li>
</ul>
</li>
<li><span class="stab portability"><code>qspi-multiwrite-flash</code></span> —  Implements the MultiwriteNorFlash trait for QSPI. Should only be enabled if your external
flash supports the semantics described <a href="https://docs.rs/embedded-storage/0.3.1/embedded_storage/nor_flash/trait.MultiwriteNorFlash.html">here</a></li>
</ul>
<h4 id="chip-selection-features"><a class="doc-anchor" href="#chip-selection-features">§</a>Chip selection features</h4>
<ul>
<li><span class="stab portability"><code>nrf52805</code></span> —  nRF52805</li>
<li><span class="stab portability"><code>nrf52810</code></span> —  nRF52810</li>
<li><span class="stab portability"><code>nrf52811</code></span> —  nRF52811</li>
<li><span class="stab portability"><code>nrf52820</code></span> —  nRF52820</li>
<li><span class="stab portability"><code>nrf52832</code></span> —  nRF52832</li>
<li><span class="stab portability"><code>nrf52833</code></span> —  nRF52833</li>
<li><span class="stab portability"><code>nrf52840</code></span> —  nRF52840</li>
<li><span class="stab portability"><code>nrf5340-app-s</code></span> —  nRF5340 application core in Secure mode</li>
<li><span class="stab portability"><code>nrf5340-app-ns</code></span> —  nRF5340 application core in Non-Secure mode</li>
<li><span class="stab portability"><code>nrf5340-net</code></span> —  nRF5340 network core</li>
<li><span class="stab portability"><code>nrf9160-s</code></span> —  nRF9160 in Secure mode</li>
<li><span class="stab portability"><code>nrf9160-ns</code></span> —  nRF9160 in Non-Secure mode</li>
</ul>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="buffered_uarte/index.html" title="mod embassy_nrf::buffered_uarte">buffered_<wbr>uarte</a></div><div class="desc docblock-short">Async buffered UART driver.</div></li><li><div class="item-name"><a class="mod" href="config/index.html" title="mod embassy_nrf::config">config</a></div><div class="desc docblock-short">Configuration options used when initializing the HAL.</div></li><li><div class="item-name"><a class="mod" href="gpio/index.html" title="mod embassy_nrf::gpio">gpio</a></div><div class="desc docblock-short">General purpose input/output (GPIO) driver.</div></li><li><div class="item-name"><a class="mod" href="gpiote/index.html" title="mod embassy_nrf::gpiote">gpiote</a></div><div class="desc docblock-short">GPIO task/event (GPIOTE) driver.</div></li><li><div class="item-name"><a class="mod" href="i2s/index.html" title="mod embassy_nrf::i2s">i2s</a></div><div class="desc docblock-short">Inter-IC Sound (I2S) driver.</div></li><li><div class="item-name"><a class="mod" href="interrupt/index.html" title="mod embassy_nrf::interrupt">interrupt</a></div><div class="desc docblock-short">Interrupt definitions.</div></li><li><div class="item-name"><a class="mod" href="nvmc/index.html" title="mod embassy_nrf::nvmc">nvmc</a></div><div class="desc docblock-short">Non-Volatile Memory Controller (NVMC, AKA internal flash) driver.</div></li><li><div class="item-name"><a class="mod" href="pdm/index.html" title="mod embassy_nrf::pdm">pdm</a></div><div class="desc docblock-short">Pulse Density Modulation (PDM) mirophone driver.</div></li><li><div class="item-name"><a class="mod" href="peripherals/index.html" title="mod embassy_nrf::peripherals">peripherals</a></div><div class="desc docblock-short">Types for the peripheral singletons.</div></li><li><div class="item-name"><a class="mod" href="ppi/index.html" title="mod embassy_nrf::ppi">ppi</a></div><div class="desc docblock-short">Programmable Peripheral Interconnect (PPI/DPPI) driver.</div></li><li><div class="item-name"><a class="mod" href="pwm/index.html" title="mod embassy_nrf::pwm">pwm</a></div><div class="desc docblock-short">Pulse Width Modulation (PWM) driver.</div></li><li><div class="item-name"><a class="mod" href="qdec/index.html" title="mod embassy_nrf::qdec">qdec</a></div><div class="desc docblock-short">Quadrature decoder (QDEC) driver.</div></li><li><div class="item-name"><a class="mod" href="rng/index.html" title="mod embassy_nrf::rng">rng</a></div><div class="desc docblock-short">Random Number Generator (RNG) driver.</div></li><li><div class="item-name"><a class="mod" href="saadc/index.html" title="mod embassy_nrf::saadc">saadc</a></div><div class="desc docblock-short">Successive Approximation Analog-to-Digital Converter (SAADC) driver.</div></li><li><div class="item-name"><a class="mod" href="spim/index.html" title="mod embassy_nrf::spim">spim</a></div><div class="desc docblock-short">Serial Peripheral Instance in master mode (SPIM) driver.</div></li><li><div class="item-name"><a class="mod" href="spis/index.html" title="mod embassy_nrf::spis">spis</a></div><div class="desc docblock-short">Serial Peripheral Instance in slave mode (SPIS) driver.</div></li><li><div class="item-name"><a class="mod" href="temp/index.html" title="mod embassy_nrf::temp">temp</a></div><div class="desc docblock-short">Builtin temperature sensor driver.</div></li><li><div class="item-name"><a class="mod" href="timer/index.html" title="mod embassy_nrf::timer">timer</a></div><div class="desc docblock-short">Timer driver.</div></li><li><div class="item-name"><a class="mod" href="twim/index.html" title="mod embassy_nrf::twim">twim</a></div><div class="desc docblock-short">I2C-compatible Two Wire Interface in master mode (TWIM) driver.</div></li><li><div class="item-name"><a class="mod" href="twis/index.html" title="mod embassy_nrf::twis">twis</a></div><div class="desc docblock-short">I2C-compatible Two Wire Interface in slave mode (TWIM) driver.</div></li><li><div class="item-name"><a class="mod" href="uarte/index.html" title="mod embassy_nrf::uarte">uarte</a></div><div class="desc docblock-short">Universal Asynchronous Receiver Transmitter (UART) driver.</div></li><li><div class="item-name"><a class="mod" href="usb/index.html" title="mod embassy_nrf::usb">usb</a></div><div class="desc docblock-short">Universal Serial Bus (USB) driver.</div></li><li><div class="item-name"><a class="mod" href="wdt/index.html" title="mod embassy_nrf::wdt">wdt</a></div><div class="desc docblock-short">Watchdog Timer (WDT) driver.</div></li></ul><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.bind_interrupts.html" title="macro embassy_nrf::bind_interrupts">bind_<wbr>interrupts</a></div><div class="desc docblock-short">Macro to bind interrupts to handlers.</div></li><li><div class="item-name"><a class="macro" href="macro.into_ref.html" title="macro embassy_nrf::into_ref">into_<wbr>ref</a></div><div class="desc docblock-short">Convenience converting into reference.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.PeripheralRef.html" title="struct embassy_nrf::PeripheralRef">Peripheral<wbr>Ref</a></div><div class="desc docblock-short">An exclusive reference to a peripheral.</div></li><li><div class="item-name"><a class="struct" href="struct.Peripherals.html" title="struct embassy_nrf::Peripherals">Peripherals</a></div><div class="desc docblock-short">Struct containing all the peripheral singletons.</div></li></ul><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.EASY_DMA_SIZE.html" title="constant embassy_nrf::EASY_DMA_SIZE">EASY_<wbr>DMA_<wbr>SIZE</a></div><div class="desc docblock-short">The maximum buffer size that the EasyDMA can send/recv in one operation.</div></li><li><div class="item-name"><a class="constant" href="constant.NVIC_PRIO_BITS.html" title="constant embassy_nrf::NVIC_PRIO_BITS">NVIC_<wbr>PRIO_<wbr>BITS</a></div><div class="desc docblock-short">Number available in the NVIC for configuring priority</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Peripheral.html" title="trait embassy_nrf::Peripheral">Peripheral</a></div><div class="desc docblock-short">Trait for any type that can be used as a peripheral of type <code>P</code>.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.init.html" title="fn embassy_nrf::init">init</a></div><div class="desc docblock-short">Initialize the <code>embassy-nrf</code> HAL with the provided configuration.</div></li></ul><h2 id="attributes" class="section-header">Attribute Macros<a href="#attributes" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="attr" href="attr.interrupt.html" title="attr embassy_nrf::interrupt">interrupt</a></div></li></ul></section></div></main></body></html>