searchState.loadedDescShard("embassy_nrf", 0, "Embassy nRF HAL\nThe maximum buffer size that the EasyDMA can send/recv in …\nGPIOTE_CH0 peripheral\nGPIOTE_CH1 peripheral\nGPIOTE_CH2 peripheral\nGPIOTE_CH3 peripheral\nGPIOTE_CH4 peripheral\nGPIOTE_CH5 peripheral\nGPIOTE_CH6 peripheral\nGPIOTE_CH7 peripheral\nI2S peripheral\nNumber available in the NVIC for configuring priority\nNVMC peripheral\nPeripheral singleton type\nP0_00 peripheral\nP0_01 peripheral\nP0_02 peripheral\nP0_03 peripheral\nP0_04 peripheral\nP0_05 peripheral\nP0_06 peripheral\nP0_07 peripheral\nP0_08 peripheral\nP0_09 peripheral\nP0_10 peripheral\nP0_11 peripheral\nP0_12 peripheral\nP0_13 peripheral\nP0_14 peripheral\nP0_15 peripheral\nP0_16 peripheral\nP0_17 peripheral\nP0_19 peripheral\nP0_20 peripheral\nP0_21 peripheral\nP0_22 peripheral\nP0_23 peripheral\nP0_24 peripheral\nP0_25 peripheral\nP0_26 peripheral\nP0_27 peripheral\nP0_28 peripheral\nP0_29 peripheral\nP0_30 peripheral\nP0_31 peripheral\nP1_00 peripheral\nP1_01 peripheral\nP1_02 peripheral\nP1_03 peripheral\nP1_04 peripheral\nP1_05 peripheral\nP1_06 peripheral\nP1_07 peripheral\nP1_08 peripheral\nP1_09 peripheral\nP1_10 peripheral\nP1_11 peripheral\nP1_12 peripheral\nP1_13 peripheral\nP1_14 peripheral\nP1_15 peripheral\nPDM peripheral\nPPI_CH0 peripheral\nPPI_CH1 peripheral\nPPI_CH10 peripheral\nPPI_CH11 peripheral\nPPI_CH12 peripheral\nPPI_CH13 peripheral\nPPI_CH14 peripheral\nPPI_CH15 peripheral\nPPI_CH16 peripheral\nPPI_CH17 peripheral\nPPI_CH18 peripheral\nPPI_CH19 peripheral\nPPI_CH2 peripheral\nPPI_CH20 peripheral\nPPI_CH21 peripheral\nPPI_CH22 peripheral\nPPI_CH23 peripheral\nPPI_CH24 peripheral\nPPI_CH25 peripheral\nPPI_CH26 peripheral\nPPI_CH27 peripheral\nPPI_CH28 peripheral\nPPI_CH29 peripheral\nPPI_CH3 peripheral\nPPI_CH30 peripheral\nPPI_CH31 peripheral\nPPI_CH4 peripheral\nPPI_CH5 peripheral\nPPI_CH6 peripheral\nPPI_CH7 peripheral\nPPI_CH8 peripheral\nPPI_CH9 peripheral\nPPI_GROUP0 peripheral\nPPI_GROUP1 peripheral\nPPI_GROUP2 peripheral\nPPI_GROUP3 peripheral\nPPI_GROUP4 peripheral\nPPI_GROUP5 peripheral\nPWM0 peripheral\nPWM1 peripheral\nPWM2 peripheral\nPWM3 peripheral\nTrait for any type that can be used as a peripheral of …\nAn exclusive reference to a peripheral.\nStruct containing all the peripheral singletons.\nQDEC peripheral\nRNG peripheral\nRTC0 peripheral\nRTC1 peripheral\nRTC2 peripheral\nSAADC peripheral\nSPI2 peripheral\nSPI3 peripheral\nTEMP peripheral\nTIMER0 peripheral\nTIMER1 peripheral\nTIMER2 peripheral\nTIMER3 peripheral\nTIMER4 peripheral\nTWISPI0 peripheral\nTWISPI1 peripheral\nUARTE0 peripheral\nUARTE1 peripheral\nUSBD peripheral\nWDT peripheral\nMacro to bind interrupts to handlers.\nAsync buffered UART driver.\nUnsafely clone (duplicate) a peripheral singleton.\nUnsafely clone (duplicate) a peripheral singleton.\nConfiguration options used when initializing the HAL.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGeneral purpose input/output (GPIO) driver.\nGPIO task/event (GPIOTE) driver.\nInter-IC Sound (I2S) driver.\nInitialize the <code>embassy-nrf</code> HAL with the provided …\nInterrupt definitions.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert a value into a <code>PeripheralRef</code>.\nConvenience converting into reference.\nMap the inner peripheral using <code>Into</code>.\nCreate a new reference to a peripheral.\nNon-Volatile Memory Controller (NVMC, AKA internal flash) …\nPulse Density Modulation (PDM) mirophone driver.\nTypes for the peripheral singletons.\nProgrammable Peripheral Interconnect (PPI/DPPI) driver.\nPulse Width Modulation (PWM) driver.\nQuadrature decoder (QDEC) driver.\nReborrow into a “child” PeripheralRef.\nRandom Number Generator (RNG) driver.\nSuccessive Approximation Analog-to-Digital Converter …\nSerial Peripheral Instance in master mode (SPIM) driver.\nSerial Peripheral Instance in slave mode (SPIS) driver.\nUnsafely create an instance of this peripheral out of thin …\nBuiltin temperature sensor driver.\nTimer driver.\nI2C-compatible Two Wire Interface in master mode (TWIM) …\nI2C-compatible Two Wire Interface in slave mode (TWIM) …\nUniversal Asynchronous Receiver Transmitter (UART) driver.\nUniversal Serial Bus (USB) driver.\nWatchdog Timer (WDT) driver.\n30801920: 115200 baud (actual rate: 115108)\n323584: 1200 baud (actual rate: 1205)\n3862528: 14400 baud (actual rate: 14401)\n5152768: 19200 baud (actual rate: 19208)\n268435456: 1Mega baud\n61865984: 230400 baud (actual rate: 231884)\n643072: 2400 baud (actual rate: 2396)\n67108864: 250000 baud\n7716864: 28800 baud (actual rate: 28777)\n8388608: 31250 baud\n10289152: 38400 baud (actual rate: 38369)\n121634816: 460800 baud (actual rate: 457143)\n1290240: 4800 baud (actual rate: 4808)\n15007744: 56000 baud (actual rate: 55944)\n15400960: 57600 baud (actual rate: 57554)\n20615168: 76800 baud (actual rate: 76923)\n251658240: 921600 baud (actual rate: 941176)\n2576384: 9600 baud (actual rate: 9598)\nBaud rate\nBuffered UARTE driver.\nWriter part of the buffered UARTE driver.\nReader part of the buffered UARTE driver.\n0: Exclude parity bit\nUART error.\n7: Include even parity bit\nInterrupt handler.\nParity\nTell this buffer that <code>amt</code> bytes have been consumed from …\nTell this buffer that <code>amt</code> bytes have been consumed from …\nReturn the contents of the internal buffer, filling it …\nReturn the contents of the internal buffer, filling it …\nFlush this output stream, ensuring that all intermediately …\nFlush this output stream, ensuring that all intermediately …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new BufferedUarte without hardware flow control.\nCreate a new BufferedUarte with hardware flow control …\nPull some bytes from this source into the specified …\nPull some bytes from this source into the specified …\nAdjust the baud rate to the provided value.\nSplit the UART in reader and writer parts.\nWrite a buffer into this writer, returning how many bytes …\nWrite a buffer into this writer, returning how many bytes …\nDebugging is allowed (APPROTECT is disabled). Default.\nConfiguration for peripherals. Default configuration …\nSettings for enabling the built in DCDC converters.\nSWD access port protection setting.\nDebugging is not allowed (APPROTECT is enabled).\nExternal source from xtal with full swing applied.\nExternal source from xtal with low swing applied.\nExternal source from xtal.\nExternal source from xtal.\nHigh frequency clock source.\nInternal source\nInternal RC oscillator\nLow frequency clock source\nAPPROTECT is not configured (neither to enable it or …\nSynthesized from the high frequency clock source.\nDCDC configuration.\nEnable or disable the debug port.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGPIOTE interrupt priority. Should be lower priority than …\nHigh frequency clock source.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLow frequency clock source.\nConfig for the second stage DCDC (VDD -&gt; DEC4), if …\nTime driver interrupt priority. Should be lower priority …\nType-erased GPIO pin\nDisconnect ‘0’, high drive ‘1’ (normally used for …\nDisconnect ‘0’ standard ‘1’ (normally used for …\nInternal pull-down resistor.\nGPIO flexible pin.\nLogical high.\nHigh drive ‘0’, high ’drive ‘1’\nHigh drive ‘0’, disconnect ‘1’ (also known as “…\nHigh drive ‘0’, standard ‘1’\nGPIO input driver.\nDigital input or output level.\nLogical low.\nNo pull.\nGPIO output driver.\nDrive strength settings for an output pin.\nInterface for a Pin that can be configured by an Input or …\nA GPIO port with up to 32 pins.\nPort 0, available on nRF9160 and all nRF52 and nRF51 MCUs.\nPort 1, only available on some MCUs.\nPull setting for an input.\nStandard ‘0’, standard ‘1’\nStandard ‘0’. disconnect ‘1’ (also known as “…\nStandard ‘0’, high drive ‘1’\nInternal pull-up resistor.\nConvert from concrete pin type PX_XX to type erased <code>AnyPin</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the pin input level.\nGet the pin input level.\nGet the current output level.\nGet the current output level.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet whether the pin input level is high.\nGet whether the pin input level is high.\nGet whether the pin input level is low.\nGet whether the pin input level is low.\nGet whether the output level is set to high.\nGet whether the output level is set to high.\nGet whether the output level is set to low.\nGet whether the output level is set to low.\nCreate GPIO input driver for a Pin with the provided Pull …\nCreate GPIO output driver for a Pin with the provided Level…\nWrap the pin in a <code>Flex</code>.\nNumber of the pin within the port (0..31)\nPort of the pin\nPeripheral port register value\nPut the pin into disconnected mode.\nPut the pin into input mode.\nPut the pin into input + output mode.\nPut the pin into output mode.\nSet the output as high.\nSet the output as high.\nSet the output level.\nSet the output level.\nSet the output as low.\nSet the output as low.\nCreate an AnyPin for a specific pin.\nToggle the output level.\nToggle the output level.\nWait for the pin to undergo any transition, i.e low to …\nWait for the pin to undergo any transition, i.e low to …\nWait for the pin to undergo a transition from high to low.\nWait for the pin to undergo a transition from high to low.\nWait until the pin is high. If it is already high, return …\nWait until the pin is high. If it is already high, return …\nWait until the pin is low. If it is already low, return …\nWait until the pin is low. If it is already low, return …\nWait for the pin to undergo a transition from low to high.\nWait for the pin to undergo a transition from low to high.\nType-erased channel.\nGPIOTE channel trait.\nSet the pin low.\nListen for high to low changes.\nGPIOTE channel driver in input mode\nPolarity for listening to events for GPIOTE input channels.\nListen for low to high changes.\nDon’t listen for any pin changes.\nGPIOTE channel driver in output mode\nPolarity of the OUT task operation for GPIOTE output …\nSet the pin high.\nListen for any change, either low to high or high to low.\nToggle the pin.\nTriggers the CLEAR task (set associated pin low).\nConvert this channel to a type-erased <code>AnyChannel</code>.\nReturns the IN event, for use with PPI.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new GPIOTE input channel driver.\nCreate a new GPIOTE output channel driver.\nGet the channel number.\nTriggers the OUT task (does the action as configured with …\nTriggers the SET task (set associated pin high).\nReturns the CLR task, for use with PPI.\nReturns the OUT task, for use with PPI.\nReturns the SET task, for use with PPI.\nAsynchronously wait for an event in this channel.\nChannel used for the most significant sample value in a …\nAligned frame format\nA 4-bytes aligned buffer. Needed for DMA access.\nApproximate sample rates.\nThe buffer length is not a multiple of the alignment.\nThe buffer address is not aligned.\nThe buffer is not in data RAM. It’s most likely in …\nThe buffer is too long.\nThe buffer is empty.\nChannels\nI2S configuration.\nType alias for <code>MultiBuffering</code> with 2 buffers.\nI2S transfer error.\nExact sample rates.\nFrame format.\nI2S full duplex stream (input &amp; output)\nI2S driver.\nI2S frame format\nI2S input\nI2S peripheral instance.\nInterrupt for this peripheral.\nInterrupt handler.\nLeft-align samples.\nI2S clock configuration.\nMaster clock generator frequency.\nMono, left channel only.\nMono, right channel only.\nSet of multiple buffers, for multi-buffering transfers.\nI2S output\nMaster clock frequency ratio\nRight-align samples.\nScale of this sample.\nSample details\nSample width.\nStereo (2 channels).\nWidth of this sample type.\n100000 Hz\n10582 Hz\n11025 Hz\n12500 Hz\n125000 Hz\nDivide by 128\n15625 Hz\n15873 Hz\n16000 Hz\n16 bit samples.\nDivide by 192\n22050 Hz\n24 bit samples.\n25000 Hz\nDivide by 256\n31250 Hz\n32000 Hz\n32 Mhz / 10 = 3200.00 kHz\n32 Mhz / 11 = 2909.09 kHz\n32 Mhz / 125 = 256.00 kHz\n32 Mhz / 15 = 2133.33 kHz\n32 Mhz / 16 = 2000.00 kHz\n32 Mhz / 21 = 1523.81 kHz\n32 Mhz / 23 = 1391.30 kHz\n32 Mhz / 30 = 1066.67 kHz\n32 Mhz / 31 = 1032.26 kHz\n32 Mhz / 32 = 1000.00 kHz\n32 Mhz / 42 = 761.90 kHz\n32 Mhz / 63 = 507.94 kHz\n32 Mhz / 8 = 4000.00 kHz\nDivide by 32\nDivide by 384\n44100 Hz\n48000 Hz\nDivide by 48\n50000 Hz\nDivide by 512\n62500 Hz\nDivide by 64\n8000 Hz\n8 bit samples.\nDivide by 96\nAlignment\nGet a mutable reference to the current buffer.\nGet a mutable reference to the current buffer.\nGet the current output and input buffers.\nChannel configuration.\nSample format\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nI2S full duplex (input and output)\nI2S input only\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>MultiBuffering</code>.\nCreate a new <code>MasterClock</code>.\nCreate a new <code>AlignedBuffer</code>.\nCreate a new I2S in master mode\nCreate a new I2S in slave mode\nI2S output only\nSets the current buffer for reception from the DMA. …\nGet the sample rate for this clock configuration.\nGet the sample rate as an integer.\nGet the sample rate as an integer.\nSample width\nSends the current buffer for transmission in the DMA. …\nSets the current buffers for output and input for …\nPrepare the initial buffer and start the I2S transfer.\nPrepare the initial buffer and start the I2S transfer.\nPrepare the initial buffers and start the I2S transfer.\nStops the I2S transfer and waits until it has stopped.\nStops the I2S transfer and waits until it has stopped.\nStops the I2S transfer and waits until it has stopped.\nReturn the divisor for this ratio\nReturn the master clock frequency.\nReturn the value that needs to be written to the register.\nReturn the value that needs to be written to the register.\n15 - CCM_AAR\n19 - COMP_LPCOMP\n14 - ECB\n38 - FPU\n6 - GPIOTE\n37 - I2S\nEnumeration of all the interrupts.\nRepresents an interrupt type that can be configured by …\n32 - MWU\n5 - NFCT\n29 - PDM\n0 - POWER_CLOCK\n28 - PWM0\n33 - PWM1\n34 - PWM2\n45 - PWM3\nThe interrupt priority level.\n18 - QDEC\n1 - RADIO\n13 - RNG\n11 - RTC0\n17 - RTC1\n36 - RTC2\n7 - SAADC\n3 - SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0\n4 - SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1\n35 - SPIM2_SPIS2_SPI2\n47 - SPIM3\n20 - SWI0_EGU0\n21 - SWI1_EGU1\n22 - SWI2_EGU2\n23 - SWI3_EGU3\n24 - SWI4_EGU4\n25 - SWI5_EGU5\n12 - TEMP\n8 - TIMER0\n9 - TIMER1\n10 - TIMER2\n26 - TIMER3\n27 - TIMER4\n2 - UARTE0_UART0\n40 - UARTE1\n39 - USBD\n16 - WDT\nDisable the interrupt.\nDisable the interrupt.\nEnable the interrupt.\nEnable the interrupt.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the priority of the interrupt.\nGet the priority of the interrupt.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if interrupt is being handled.\nCheck if interrupt is being handled.\nCheck if interrupt is enabled.\nCheck if interrupt is enabled.\nCheck if interrupt is pending.\nCheck if interrupt is pending.\nSet interrupt pending.\nSet interrupt pending.\nSet the interrupt priority.\nSet the interrupt priority.\nSet the interrupt priority with an already-acquired …\nSet the interrupt priority with an already-acquired …\nType-level interrupt infrastructure.\nUnset interrupt pending.\nUnset interrupt pending.\nCompile-time assertion that an interrupt has been bound to …\nCCM_AAR typelevel interrupt.\nCOMP_LPCOMP typelevel interrupt.\nECB typelevel interrupt.\nFPU typelevel interrupt.\nGPIOTE typelevel interrupt.\nInterrupt handler trait.\nI2S typelevel interrupt.\nInterrupt enum variant.\nType-level interrupt.\nMWU typelevel interrupt.\nNFCT typelevel interrupt.\nPDM typelevel interrupt.\nPOWER_CLOCK typelevel interrupt.\nPWM0 typelevel interrupt.\nPWM1 typelevel interrupt.\nPWM2 typelevel interrupt.\nPWM3 typelevel interrupt.\nQDEC typelevel interrupt.\nRADIO typelevel interrupt.\nRNG typelevel interrupt.\nRTC0 typelevel interrupt.\nRTC1 typelevel interrupt.\nRTC2 typelevel interrupt.\nSAADC typelevel interrupt.\nSPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0 typelevel interrupt.\nSPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1 typelevel interrupt.\nSPIM2_SPIS2_SPI2 typelevel interrupt.\nSPIM3 typelevel interrupt.\nSWI0_EGU0 typelevel interrupt.\nSWI1_EGU1 typelevel interrupt.\nSWI2_EGU2 typelevel interrupt.\nSWI3_EGU3 typelevel interrupt.\nSWI4_EGU4 typelevel interrupt.\nSWI5_EGU5 typelevel interrupt.\nTEMP typelevel interrupt.\nTIMER0 typelevel interrupt.\nTIMER1 typelevel interrupt.\nTIMER2 typelevel interrupt.\nTIMER3 typelevel interrupt.\nTIMER4 typelevel interrupt.\nUARTE0_UART0 typelevel interrupt.\nUARTE1 typelevel interrupt.\nUSBD typelevel interrupt.\nWDT typelevel interrupt.\nDisable the interrupt.\nDisable the interrupt.\nEnable the interrupt.\nEnable the interrupt.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the priority of the interrupt.\nGet the priority of the interrupt.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if interrupt is enabled.\nCheck if interrupt is enabled.\nCheck if interrupt is pending.\nCheck if interrupt is pending.\nInterrupt handler function.\nSet interrupt pending.\nSet interrupt pending.\nSet the interrupt priority.\nSet the interrupt priority.\nSet the interrupt priority with an already-acquired …\nSet the interrupt priority with an already-acquired …\nUnset interrupt pending.\nUnset interrupt pending.\nError type for NVMC operations.\nSize of NVMC flash in bytes.\nNon-Volatile Memory Controller (NVMC) that implements the …\nOperation using a location not in flash.\nErase size of NVMC flash in bytes.\nUnaligned operation or using unaligned buffers.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate Nvmc driver.\nPDM is already running\nBuffer is too long.\nBuffer is empty\nPDM microphone driver Config\n138412032: PDM_CLK = 32 MHz / 31 = 1.032 MHz. Nominal …\nPDM edge polarity\nPDM error.\nPDM_CLK frequency configuration\nPDM peripheral instance.\nInterrupt for this peripheral.\nInterrupt handler.\nLeft edge is falling\nLeft edge is rising\nMono (1 channel)\nPDM is not running\nPDM operation mode.\nPDM microphone interface\n0: Ratio of 64\n1: Ratio of 80\nSelects the ratio between PDM_CLK and output sample rate\nThe sampler processed the samples and is ready for more.\nThe state of a continuously running sampler. While it …\nStereo (2 channels)\nThe sampler is done processing samples.\n134217728: PDM_CLK = 32 MHz / 32 = 1.000 MHz\n142606336: PDM_CLK = 32 MHz / 30 = 1.067 MHz\n159383552: PDM_CLK = 32 MHz / 26 = 1.231 MHz\n167772160: PDM_CLK = 32 MHz / 25 = 1.280 MHz. Nominal …\n176160768: PDM_CLK = 32 MHz / 24 = 1.333 MHz\nOn which edge the left channel should be samples\nClock frequency\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGain left in dB\nGain right in dB\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate PDM driver\nUse stero or mono operation\nClock ratio\nContinuous sampling with double buffers.\nSample data into the given buffer.\nAdjust the gain of the PDM microphone on the fly\nStart sampling microphon data into a dummy buffer Usefull …\nStop sampling microphon data inta a dummy buffer\nGPIOTE_CH0 peripheral\nGPIOTE_CH1 peripheral\nGPIOTE_CH2 peripheral\nGPIOTE_CH3 peripheral\nGPIOTE_CH4 peripheral\nGPIOTE_CH5 peripheral\nGPIOTE_CH6 peripheral\nGPIOTE_CH7 peripheral\nI2S peripheral\nNVMC peripheral\nP0_00 peripheral\nP0_01 peripheral\nP0_02 peripheral\nP0_03 peripheral\nP0_04 peripheral\nP0_05 peripheral\nP0_06 peripheral\nP0_07 peripheral\nP0_08 peripheral\nP0_09 peripheral\nP0_10 peripheral\nP0_11 peripheral\nP0_12 peripheral\nP0_13 peripheral\nP0_14 peripheral\nP0_15 peripheral\nP0_16 peripheral\nP0_17 peripheral\nP0_19 peripheral\nP0_20 peripheral\nP0_21 peripheral\nP0_22 peripheral\nP0_23 peripheral\nP0_24 peripheral\nP0_25 peripheral\nP0_26 peripheral\nP0_27 peripheral\nP0_28 peripheral\nP0_29 peripheral\nP0_30 peripheral\nP0_31 peripheral\nP1_00 peripheral\nP1_01 peripheral\nP1_02 peripheral\nP1_03 peripheral\nP1_04 peripheral\nP1_05 peripheral\nP1_06 peripheral\nP1_07 peripheral\nP1_08 peripheral\nP1_09 peripheral\nP1_10 peripheral\nP1_11 peripheral\nP1_12 peripheral\nP1_13 peripheral\nP1_14 peripheral\nP1_15 peripheral\nPDM peripheral\nPPI_CH0 peripheral\nPPI_CH1 peripheral\nPPI_CH10 peripheral\nPPI_CH11 peripheral\nPPI_CH12 peripheral\nPPI_CH13 peripheral\nPPI_CH14 peripheral\nPPI_CH15 peripheral\nPPI_CH16 peripheral\nPPI_CH17 peripheral\nPPI_CH18 peripheral\nPPI_CH19 peripheral\nPPI_CH2 peripheral\nPPI_CH20 peripheral\nPPI_CH21 peripheral\nPPI_CH22 peripheral\nPPI_CH23 peripheral\nPPI_CH24 peripheral\nPPI_CH25 peripheral\nPPI_CH26 peripheral\nPPI_CH27 peripheral\nPPI_CH28 peripheral\nPPI_CH29 peripheral\nPPI_CH3 peripheral\nPPI_CH30 peripheral\nPPI_CH31 peripheral\nPPI_CH4 peripheral\nPPI_CH5 peripheral\nPPI_CH6 peripheral\nPPI_CH7 peripheral\nPPI_CH8 peripheral\nPPI_CH9 peripheral\nPPI_GROUP0 peripheral\nPPI_GROUP1 peripheral\nPPI_GROUP2 peripheral\nPPI_GROUP3 peripheral\nPPI_GROUP4 peripheral\nPPI_GROUP5 peripheral\nPWM0 peripheral\nPWM1 peripheral\nPWM2 peripheral\nPWM3 peripheral\nQDEC peripheral\nRNG peripheral\nRTC0 peripheral\nRTC1 peripheral\nRTC2 peripheral\nSAADC peripheral\nSPI2 peripheral\nSPI3 peripheral\nTEMP peripheral\nTIMER0 peripheral\nTIMER1 peripheral\nTIMER2 peripheral\nTIMER3 peripheral\nTIMER4 peripheral\nTWISPI0 peripheral\nTWISPI1 peripheral\nUARTE0 peripheral\nUARTE1 peripheral\nUSBD peripheral\nWDT peripheral\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nUnsafely create an instance of this peripheral out of thin …\nThe any configurable channel can represent any …\nA type erased PPI group.\nThe any channel can represent any static channel at …\nInterface for PPI channels.\nInterface for PPI channels that can be configured.\nRepresents an event that a peripheral can publish.\nInterface for a group of PPI channels.\nPPI channel driver.\nPPI channel group driver.\nInterface for PPI channels that cannot be configured.\nRepresents a task that a peripheral can do.\nAdd a PPI channel to this group.\nClear the current register’s triggered state, reverting …\nConvert into a type erased configurable channel.\nConvert into a type erased static channel.\nConvert into a type erased group.\nDisables the channel.\nDisable all the channels in this group.\nEnables the channel.\nEnable all the channels in this group.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDescribes whether this Event is currently in a triggered …\nCreate a new PPI group driver.\nConfigure PPI channel to trigger <code>task</code> on <code>event</code>.\nConfigure PPI channel to trigger both <code>task1</code> and <code>task2</code> on …\nCreate a new <code>Task</code> from a task register pointer\nCreate a new <code>Event</code> from an event register pointer\nConfigure PPI channel to trigger <code>task</code>.\nReturns the number of the channel\nReturns the number of the group.\nRemove a PPI channel from this group.\nGet a reference to the “disable all” task.\nGet a reference to the “enable all” task.\nTriggers this task.\nEasyDMA can only read from data memory, read only buffers …\nProvided sequence will be used across all channels\nConfiguration for the PWM as a whole.\nSelects up mode or up-and-down mode for the counter\nDivide by 1\nDivide by 128\nDivide by 16\nDivide by 2\nDivide by 32\nDivide by 4\nDivide by 64\nDivide by 8\nPWM error\nProvided sequence contains grouped values for each channel …\nProvided sequence contains individual values for each …\nRepeat until <code>stop</code> is called.\nRepeat until <code>stop</code> is called.\nPWM peripheral instance.\nInterrupt for this peripheral.\nRun two sequences n loops i.e. (n * (seq0 + …\nStart with Sequence 1\nPWM Base clock is system clock (16MHz) divided by prescaler\nA composition of a sequence buffer and its configuration.\nConfiguration per sequence\nHow the sequence values are distributed across the channels\nHow many loops to run two sequences\nSequencePwm allows you to offload the updating of a …\nMin Sequence count is 1\nMax Sequence size is 32767\nA composition of sequences that can be started and stopped.\nSimplePwm is the traditional pwm interface you’re …\nHow many times to run a single sequence\nA single sequence that can be started and stopped. Takes …\nWhich sequence to start a loop with\nRun a single sequence n Times total.\nUp counter (edge-aligned PWM duty cycle)\nUp and down counter (center-aligned PWM duty cycle)\nSimilar to Individual mode, but only three channels are …\nStart with Sequence 0\nConfiguration associated with the sequence.\nSelects up mode or up-and-down mode for the counter\nDisables the PWM generator. Does NOT clear the last duty …\nEnables the PWM generator.\nNumber of PWM periods after the sequence ends before …\nReturns reference to <code>LoopsDone</code> event endpoint for PPI.\nReturns reference to <code>PwmPeriodEnd</code> event endpoint for PPI.\nReturns reference to <code>Seq0 Started</code> event endpoint for PPI.\nReturns reference to <code>Seq1 End</code> event endpoint for PPI.\nReturns reference to <code>Seq1 Started</code> event endpoint for PPI.\nReturns reference to <code>Seq0 End</code> event endpoint for PPI.\nReturns reference to <code>Stopped</code> event endpoint for PPI.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the maximum duty cycle value.\nTop value to be compared against buffer values\nCreate a new <code>Sequence</code>\nCreate a new sequencer\nCreate a new double sequence. In the absence of sequence …\nCreate a new 1-channel PWM\nCreate a new 1-channel PWM\nCreate a new 2-channel PWM\nCreate a new 2-channel PWM\nCreate a new 3-channel PWM\nCreate a new 3-channel PWM\nCreate a new 4-channel PWM\nCreate a new 4-channel PWM\nReturns the PWM output frequency.\nGets the PWM clock prescaler.\nConfiguration for PWM_CLK\nNumber of PWM periods to delay between each sequence sample\nHow a sequence is read from RAM and is spread to the …\nSets duty cycle (15 bit) for a PWM channel.\nSets the maximum duty cycle value.\nSets the PWM output frequency.\nSets the PWM clock prescaler.\nStart or restart playback.\nStart or restart playback. The sequence mode applies to …\nStop playback. Disables the peripheral. Does NOT clear the …\nStop playback. Disables the peripheral. Does NOT clear the …\nReturns reference to <code>NextStep</code> task endpoint for PPI.\nReturns reference to <code>Seq0 Start</code> task endpoint for PPI.\nReturns reference to <code>Seq1 Started</code> task endpoint for PPI.\nReturns reference to <code>Stop</code> task endpoint for PPI.\nThe words comprising the sequence. Must not exceed 32767 …\nActive high (a high output turns on the LED).\nActive low (a low output turns on the LED).\nQDEC config\nqdec peripheral instance.\nInterrupt for this peripheral.\nInterrupt handler.\nLED polarity\nNumber of samples taken.\nQuadrature decoder driver.\nSample period\n1024 us\n10 samples\n120 samples\n128 us\n131 ms\n160 samples\n16384 us\n1 sample\n200 samples\n2048 us\n240 samples\n256 us\n280 samples\n32 ms\n4096 us\n40 samples\n512 us\n65 ms\n80 samples\n8192 us\nEnable/disable input debounce filters\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet LED output pin polarity\nTime period the LED is switched ON prior to sampling …\nCreate a new QDEC.\nCreate a new QDEC, with a pin for LED output.\nNumber of samples\nSample period\nPerform an asynchronous read of the decoder. The returned …\nRNG peripheral instance.\nInterrupt for this peripheral.\nInterrupt handler.\nA wrapper around an nRF RNG peripheral.\nFill the buffer with random bytes, blocking version.\nFill the buffer with random bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new RNG driver from the <code>RNG</code> peripheral and …\nEnable or disable the RNG’s bias correction.\nA type-erased SAADC input.\nBypass resistor ladder\nBypass oversampling\nValue returned by the SAADC callback, deciding what …\nUsed to configure an individual SAADC peripheral channel.\nUsed to configure the SAADC peripheral.\nThe SAADC should keep sampling and calling the callback.\nSAADC error\n1\n1/2\n1/3\n1/4\n1/5\n1/6\n2\n4\nGain control\nInternal reference (0.6 V)\nAn input that can be used as either or negative end of a …\nInterrupt handler.\nOversample 128x\nOversample 16x\nOversample 256x\nOversample 2x\nOversample 32x\nOversample 4x\nOversample 64x\nOversample 8x\nOversample control\nPull-down to GND\nPull-up to VDD\nReference control\nPositive channel resistor control\nSet the resolution\nOne-shot and continuous SAADC.\nThe SAADC should stop sampling, and return.\nAcquisition time, the time the SAADC uses to sample the …\nSet input at VDD/2\nVDD/4 as reference\nA dummy <code>Input</code> pin implementation for SAADC peripheral …\nA dummy <code>Input</code> pin implementation for SAADC peripheral …\n10 bits\n10 us\n12 bits\n14 bits\n15 us\n20 us\n3 us\n40 us\n5 us\n8 bits\nPerform SAADC calibration. Completes when done.\nDefault configuration for single channel sampling.\nConvert this SAADC input to a type-erased <code>AnyInput</code>.\nDefault configuration for differential channel sampling.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGain used to control the effective input range of the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new SAADC driver.\nAverage 2^<code>oversample</code> input samples before transferring the …\nReference voltage of the SAADC input.\nPositive channel resistor control.\nOutput resolution in bits.\nContinuous sampling with double buffers.\nContinuous sampling on a single channel with double …\nOne shot sampling. The buffer must be the same size as the …\nDefault configuration for single ended channel sampling.\nAcquisition time in microseconds.\nEasyDMA can only read from data memory, read only buffers …\nData in “captured” on the first clock transition\nData in “captured” on the second clock transition\nSPIM configuration.\nSPIM error\nSPI master data rate\nClock signal high when idle\nClock signal low when idle\nSPIM peripheral instance\nInterrupt for this peripheral.\nInterrupt handler.\n33554432: 125 kbps\n67108864: 250 kbps\n134217728: 500 kbps\n268435456: 1 Mbps\n167772160: 16 Mbps\n536870912: 2 Mbps\n335544320: 32 Mbps\n1073741824: 4 Mbps\n2147483648: 8 Mbps\nHelper for CPOL = 0, CPHA = 0\nHelper for CPOL = 0, CPHA = 1\nHelper for CPOL = 1, CPHA = 0\nHelper for CPOL = 1, CPHA = 1\nSPI mode\nClock phase\nClock polarity\nRX buffer was too long.\nSPIM driver.\nTX buffer was too long.\nReads data from the SPI bus without sending anything. …\nSimultaneously sends and receives data. Blocks until the …\nSame as <code>blocking_transfer</code> but will fail instead of copying …\nSimultaneously sends and receives data. Places the …\nSends data, discarding any received data. Blocks  until …\nSame as <code>blocking_write</code> but will fail instead of copying …\nFrequency\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSPI mode\nCreate a new SPIM driver.\nCreate a new SPIM driver, capable of RX only (MISO only).\nCreate a new SPIM driver, capable of TX only (MOSI only).\nCreate a new SPIM driver, capable of TX only (MOSI only), …\nOverread character.\nClock phase\nClock polarity\nReads data from the SPI bus without sending anything.\nSimultaneously sends and receives data. If necessary, the …\nSame as <code>transfer</code> but will fail instead of copying data …\nSimultaneously sends and receives data. Places the …\nSends data, discarding any received data. If necessary, …\nSame as <code>write</code> but will fail instead of copying data into …\nEasyDMA can only read from data memory, read only buffers …\nData in “captured” on the first clock transition\nData in “captured” on the second clock transition\nSPIS configuration.\nSPIS error\nClock signal high when idle\nClock signal low when idle\nSPIS peripheral instance\nInterrupt for this peripheral.\nInterrupt handler.\nHelper for CPOL = 0, CPHA = 0\nHelper for CPOL = 0, CPHA = 1\nHelper for CPOL = 1, CPHA = 0\nHelper for CPOL = 1, CPHA = 1\nSPI mode\nClock phase\nClock polarity\nRX buffer was too long.\nSPIS driver.\nTX buffer was too long.\nAutomatically make the firmware side acquire the semaphore …\nReads data from the SPI bus without sending anything. …\nSimultaneously sends and receives data. Blocks until the …\nSame as <code>blocking_transfer</code> but will fail instead of copying …\nSimultaneously sends and receives data. Places the …\nSends data, discarding any received data. Blocks  until …\nSame as <code>blocking_write</code> but will fail instead of copying …\nDefault byte.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks if last transaction overflowed.\nChecks if last transaction overread.\nSPI mode\nCreate a new SPIS driver.\nCreate a new SPIS driver, capable of RX only (MOSI only).\nCreate a new SPIS driver, capable of TX only (MISO only).\nCreate a new SPIS driver, capable of TX only (MISO only) …\nOverread character.\nClock phase\nClock polarity\nReads data from the SPI bus without sending anything. …\nSimultaneously sends and receives data. If necessary, the …\nSame as <code>transfer</code> but will fail instead of copying data …\nSimultaneously sends and receives data. Places the …\nSends data, discarding any received data. If necessary, …\nSame as <code>write</code> but will fail instead of copying data into …\nInterrupt handler.\nBuiltin temperature sensor driver.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new temperature sensor driver.\nPerform an asynchronous temperature measurement. The …\nA representation of a timer’s Capture/Compare (CC) …\nExtended timer instance.\n125kHz\n16MHz\n1MHz\n250kHz\n2MHz\n31250Hz\n4MHz\n500kHz\n62500Hz\n8MHz\nTimer frequency\nBasic Timer instance.\nInterrupt for this peripheral.\nnRF Timer driver.\nCapture the current value of the timer’s counter in this …\nReturns this timer’s <code>n</code>th CC register.\nReset the timer’s counter to 0.\nReturns this CC register’s COMPARE event, for use with …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>Timer</code> driver.\nCreate a new <code>Timer</code> driver in counter mode.\nGet the current value stored in the register.\nChange the timer’s frequency.\nEnable the shortcut between this CC register’s COMPARE …\nEnable the shortcut between this CC register’s COMPARE …\nStarts the timer.\nStops the timer.\nReturns this CC register’s CAPTURE task, for use with …\nReturns the CLEAR task, for use with PPI.\nReturns the COUNT task, for use with PPI.\nReturns the START task, for use with PPI.\nReturns the STOP task, for use with PPI.\nDisable the shortcut between this CC register’s COMPARE …\nDisable the shortcut between this CC register’s COMPARE …\nSet the value stored in the register.\nDidn’t receive an ACK bit after the address byte. …\nThe buffer is not in data RAM. It’s most likely in …\nTWIM config.\nDidn’t receive an ACK bit after a data byte.\nTWI error.\nTWI frequency\nTWIM peripheral instance.\nInterrupt for this peripheral.\nInterrupt handler.\n100 kbps\n250 kbps\n400 kbps\nOverrun error.\nData reception failed.\nRX buffer was too long.\nTimeout error.\nData transmit failed.\nTWI driver.\nTX buffer was too long.\nRead from an I2C slave.\nRead from an I2C slave.\nWrite to an I2C slave.\nSame as <code>blocking_write</code> but will fail instead of copying …\nSame as <code>blocking_write</code> but will fail instead of copying …\nWrite data to an I2C slave, then read data from the slave …\nSame as <code>blocking_write_read</code> but will fail instead of …\nSame as <code>blocking_write_read</code> but will fail instead of …\nWrite data to an I2C slave, then read data from the slave …\nWrite to an I2C slave with timeout.\nFrequency\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new TWI driver.\nRead from an I2C slave.\nEnable high drive for the SCL line.\nEnable internal pullup for the SCL line.\nEnable high drive for the SDA line.\nEnable internal pullup for the SDA line.\nWrite to an I2C slave.\nSame as <code>write</code> but will fail instead of copying data into …\nWrite data to an I2C slave, then read data from the slave …\nSame as <code>write_read</code> but will fail instead of copying data …\nThe buffer is not in data RAM. It’s most likely in …\nBus error.\nReceived command\nTWIS config.\nDidn’t receive an ACK bit after a data byte.\nTWIS error.\nTWIS peripheral instance.\nInterrupt for this peripheral.\nInterrupt handler.\nOverread\nOverflow\nRead\nRX buffer was too long.\nTimeout\nTWIS driver.\nTX buffer was too long.\nWrite\nWrite+read\nFirst address\nSecond address, optional.\nReturns matched address for latest command.\nReturns the index of the address matched in the latest …\nWait for commands from an I2C master. <code>buffer</code> is provided …\nWait for commands from an I2C master, with timeout. <code>buffer</code> …\nRespond to an I2C master READ command. Returns the number …\nSame as <code>blocking_respond_to_read</code> but will fail instead of …\nSame as <code>blocking_respond_to_read_timeout</code> but will fail …\nRespond to an I2C master READ command with timeout. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWait asynchronously for commands from an I2C master. <code>buffer</code>…\nCreate a new TWIS driver.\nOverread character.\nRespond to an I2C master READ command, asynchronously. …\nSame as <code>respond_to_read</code> but will fail instead of copying …\nEnable high drive for the SCL line.\nEnable internal pullup for the SCL line.\nEnable high drive for the SDA line.\nEnable internal pullup for the SDA line.\n30801920: 115200 baud (actual rate: 115108)\n323584: 1200 baud (actual rate: 1205)\n3862528: 14400 baud (actual rate: 14401)\n5152768: 19200 baud (actual rate: 19208)\n268435456: 1Mega baud\n61865984: 230400 baud (actual rate: 231884)\n643072: 2400 baud (actual rate: 2396)\n67108864: 250000 baud\n7716864: 28800 baud (actual rate: 28777)\n8388608: 31250 baud\n10289152: 38400 baud (actual rate: 38369)\n121634816: 460800 baud (actual rate: 457143)\n1290240: 4800 baud (actual rate: 4808)\n15007744: 56000 baud (actual rate: 55944)\n15400960: 57600 baud (actual rate: 57554)\n20615168: 76800 baud (actual rate: 76923)\n251658240: 921600 baud (actual rate: 941176)\n2576384: 9600 baud (actual rate: 9598)\nBaud rate\nThe buffer is not in data RAM. It’s most likely in …\nBuffer was too long.\nUARTE config.\n0: Exclude parity bit\nUART error.\n7: Include even parity bit\nUARTE peripheral instance.\nInterrupt for this peripheral.\nInterrupt handler.\nParity\nUARTE driver.\nReceiver part of the UARTE driver.\nReceiver part of the UARTE driver, with <code>read_until_idle</code> …\nTransmitter part of the UARTE driver.\nBaud rate.\nRead bytes until the buffer is filled.\nRead bytes until the buffer is filled.\nRead bytes until the buffer is filled.\nRead bytes until the buffer is filled, or the line becomes …\nWrite all bytes in the buffer.\nWrite all bytes in the buffer.\nSame as <code>blocking_write</code> but will fail instead of copying …\nSame as <code>write_from_ram</code> but will fail instead of copying …\nReturn the endtx event for use with PPI\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new UARTE without hardware flow control\nCreate a new tx-only UARTE without hardware flow control\nCreate a new rx-only UARTE without hardware flow control\nCreate a new UARTE with hardware flow control (RTS/CTS)\nCreate a new tx-only UARTE with hardware flow control …\nCreate a new rx-only UARTE with hardware flow control …\nParity bit.\nRead bytes until the buffer is filled.\nRead bytes until the buffer is filled.\nRead bytes until the buffer is filled.\nRead bytes until the buffer is filled, or the line becomes …\nSplit the Uarte into the transmitter and receiver parts.\nSplit the Uarte into the transmitter and receiver with …\nUpgrade to an instance that supports idle line detection.\nWrite all bytes in the buffer.\nWrite all bytes in the buffer.\nSame as <code>write</code> but will fail instead of copying data into …\nSame as <code>write</code> but will fail instead of copying data into …\nUSB bus.\nUSB control pipe.\nUSB driver.\nUSB endpoint.\nType-level marker for IN endpoints.\nUSB peripheral instance.\nInterrupt for this peripheral.\nInterrupt handler.\nType-level marker for OUT endpoints.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new USB driver.\nTrait and implementations for performing VBUS detection.\n<code>VbusDetect</code> implementation using the native hardware POWER …\nInterrupt handler.\nSoftware-backed <code>VbusDetect</code> implementation.\nTrait for detecting USB VBUS power.\nReport whether power was detected.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReport whether power is detected.\nCreate a new <code>VbusDetectNative</code>.\nCreate a new <code>SoftwareVbusDetect</code>.\nReport when USB power is ready.\nWait until USB power is ready.\nWDT configuration.\nWatchdog driver.\nWatchdog handle.\nIs the watchdog still awaiting pets from any handle?\nDisable the watchdog interrupt.\nEnable the watchdog interrupt.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHas this handle been pet within the current window?\nPet the watchdog.\nShould the watchdog continue to count when the CPU is …\nShould the watchdog continue to count during sleep modes?\nSteal a watchdog handle by index.\nNumber of 32768 Hz ticks in each watchdog period.\nCreate a config structure from the current configuration …\nTry to create a new watchdog driver.")