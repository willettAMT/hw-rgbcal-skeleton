<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Target side implementation of the RTT (Real-Time Transfer) I/O protocol"><title>rtt_target - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="rtt_target" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.1 (4eb161250 2025-03-15)" data-channel="1.85.1" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../rtt_target/index.html">rtt_<wbr>target</a><span class="version">0.4.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#hardware-support" title="Hardware support">Hardware support</a></li><li><a href="#initialization" title="Initialization">Initialization</a></li><li><a href="#channels-and-virtual-terminals" title="Channels and virtual terminals">Channels and virtual terminals</a></li><li><a href="#channel-modes" title="Channel modes">Channel modes</a></li><li><a href="#printing" title="Printing">Printing</a></li><li><a href="#debug" title="Debug">Debug</a></li><li><a href="#reading" title="Reading">Reading</a></li></ul><h3><a href="#macros">Crate Items</a></h3><ul class="block"><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>rtt_target</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/rtt_target/lib.rs.html#1-404">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Target side implementation of the RTT (Real-Time Transfer) I/O protocol</p>
<p>RTT implements input and output to/from a debug probe using in-memory ring buffers and memory
polling. This enables debug logging from the microcontroller with minimal delays and no
blocking, making it usable even in real-time applications where e.g. semihosting delays cannot
be tolerated.</p>
<h2 id="hardware-support"><a class="doc-anchor" href="#hardware-support">§</a>Hardware support</h2>
<p>This crate is platform agnostic and can be used on any chip that supports background memory
access via its debug interface. The printing macros require a critical section which is
platform-dependent. Built-in ARM Cortex-M support can be enabled with the “cortex-m” feature,
and RISC-V support can be enabled with the “riscv” feature.</p>
<p>To interface with RTT from the host computer, a debug probe such as an ST-Link or J-Link is
required. The normal debug protocol (e.g. SWD) is used to access RTT, so no extra connections
such as SWO pins are needed.</p>
<h2 id="initialization"><a class="doc-anchor" href="#initialization">§</a>Initialization</h2>
<p>RTT must be initialized at the start of your program using one of the init macros. See the
macros for more details.</p>
<p>The initialization macros return channel objects that can be used for writing and reading.
Different channel objects can safely be used concurrently in different contexts without locking.
In an interrupt-based application with realtime constraints you could use a separate channel for
every interrupt context to allow for lock-free logging.</p>
<h2 id="channels-and-virtual-terminals"><a class="doc-anchor" href="#channels-and-virtual-terminals">§</a>Channels and virtual terminals</h2>
<p>RTT supports multiple <em>channels</em> in both directions. Up channels go from target to host, and
down channels go from host to target. Each channel is identified by its direction and number.</p>
<p>By convention channel 0 is reserved for terminal use. In the up direction there is a set of
escape sequences that further enable the single channel to be treated as up to 16 <em>virtual
terminals</em>. This can be used to separate different types of messages (for example, log levels)
from each other without having to allocate memory for multiple buffers. As a downside, multiple
threads cannot write to the same channel at once, even if using different virtual terminal
numbers, so access has to be synchronized. Down channel 0 is conventionally used for keyboard
input.</p>
<p><strong>Note:</strong> Some host side programs only display channel 0 by default, so to see the other
channels you might need to configure them appropriately.</p>
<p>The other channels can be used to either enable concurrent use from multiple sources without
locking, or to send e.g. binary data in either direction.</p>
<p>Channel 0 can also be used for arbitrary data, but most tools expect it to be plain text.</p>
<h2 id="channel-modes"><a class="doc-anchor" href="#channel-modes">§</a>Channel modes</h2>
<p>By default, channels start in <a href="enum.ChannelMode.html#variant.NoBlockSkip" title="variant rtt_target::ChannelMode::NoBlockSkip"><code>NoBlockSkip</code></a> mode, which discards
data if the buffer is full. This enables RTT to not crash the application if there is no debug
probe attached or if the host is not reading the buffers. However if the application outputs
faster than the host can read (which is easy to do, because writing is very fast), messages will
be lost. Channels can be set to blocking mode if this is desirable, however in that case the
application will likely freeze when the buffer fills up if a debugger is not attached.</p>
<p>The channel mode can also be changed on the fly by the debug probe. Therefore it may be
advantageous to use a non-blocking mode in your microcontroller code, and set a blocking mode as
needed when debugging. That way you will never end up with an application that freezes without a
debugger connected.</p>
<h2 id="printing"><a class="doc-anchor" href="#printing">§</a>Printing</h2>
<p>For no-hassle output the <a href="macro.rprint.html" title="macro rtt_target::rprint"><code>rprint</code></a> and <a href="macro.rprintln.html" title="macro rtt_target::rprintln"><code>rprintln</code></a> macros are provided. They use a single down
channel defined at initialization time, and a critical section for synchronization, and they
therefore work exactly like the standard <code>println</code> style macros. They can be used from any
context. The <a href="macro.rtt_init_print.html" title="macro rtt_target::rtt_init_print"><code>rtt_init_print</code></a> convenience macro initializes printing on channel 0.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rtt_target::{rtt_init_print, rprintln};

<span class="kw">fn </span>main() -&gt; ! {
    <span class="macro">rtt_init_print!</span>();
    <span class="kw">loop </span>{
        <span class="macro">rprintln!</span>(<span class="string">"Hello, world!"</span>);
    }
}</code></pre></div>
<h2 id="debug"><a class="doc-anchor" href="#debug">§</a>Debug</h2>
<p>To use rtt functionality only in debug builds use macros prefixed with <code>debug_*</code>. They have
exactly the same functionality as without debug - the only difference is that they are removed
when built with <code>--release</code>. It’s save to use <a href="macro.debug_rprintln.html" title="macro rtt_target::debug_rprintln"><code>debug_rprintln</code></a> and <a href="macro.debug_rprint.html" title="macro rtt_target::debug_rprint"><code>debug_rprint</code></a> even if
rtt was initialized with <a href="macro.rtt_init.html" title="macro rtt_target::rtt_init"><code>rtt_init</code></a> instead of <a href="macro.debug_rtt_init.html" title="macro rtt_target::debug_rtt_init"><code>debug_rtt_init</code></a>.</p>
<p>Under the hood this uses the [<code>debug-assertions</code>] flag. Set this flag to true to include all debug
macros also in release mode.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rtt_target::{debug_rtt_init_print, debug_rprintln};

<span class="kw">fn </span>main() -&gt; ! {
    <span class="macro">debug_rtt_init_print!</span>(); <span class="comment">// nop in --release
    </span><span class="kw">loop </span>{
        <span class="macro">debug_rprintln!</span>(<span class="string">"Hello, world!"</span>); <span class="comment">// not present in --release
    </span>}
}</code></pre></div>
<p>The macros also support an extended syntax to print to different RTT virtual terminals.</p>
<p>Please note that because a critical section is used, printing into a blocking channel will cause
the application to block and freeze when the buffer is full.</p>
<h2 id="reading"><a class="doc-anchor" href="#reading">§</a>Reading</h2>
<p>The following example shows how to set up the RTT to read simple input sent from the host
to the target.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rtt_target::{rtt_init_default, rprintln};

<span class="kw">fn </span>main() -&gt; ! {
    <span class="kw">let </span>mode = <span class="kw">loop </span>{
        read = channels.down.<span class="number">0</span>.read(<span class="kw-2">&amp;mut </span>read_buf);
        <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..read {
            <span class="kw">match </span>read_buf[i] <span class="kw">as </span>char {
                <span class="string">'0' </span>=&gt; <span class="kw">break </span><span class="number">0</span>,
                <span class="string">'1' </span>=&gt; <span class="kw">break </span><span class="number">1</span>,
                <span class="kw">_ </span>=&gt; {}
            }
        }
    };
}</code></pre></div>
</div></details><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.debug_rprint.html" title="macro rtt_target::debug_rprint">debug_<wbr>rprint</a></div><div class="desc docblock-short">The same as [<code>rprint</code>] macro but works only in debug</div></li><li><div class="item-name"><a class="macro" href="macro.debug_rprintln.html" title="macro rtt_target::debug_rprintln">debug_<wbr>rprintln</a></div><div class="desc docblock-short">The same as [<code>rprintln</code>] macro but works only in debug</div></li><li><div class="item-name"><a class="macro" href="macro.debug_rtt_init.html" title="macro rtt_target::debug_rtt_init">debug_<wbr>rtt_<wbr>init</a></div><div class="desc docblock-short">The same as <a href="macro.rtt_init.html" title="macro rtt_target::rtt_init"><code>rtt_init</code></a> macro but works only in debug</div></li><li><div class="item-name"><a class="macro" href="macro.debug_rtt_init_default.html" title="macro rtt_target::debug_rtt_init_default">debug_<wbr>rtt_<wbr>init_<wbr>default</a></div><div class="desc docblock-short">The same as <a href="macro.rtt_init_default.html" title="macro rtt_target::rtt_init_default"><code>rtt_init_default</code></a> macro but works only in debug</div></li><li><div class="item-name"><a class="macro" href="macro.rdbg.html" title="macro rtt_target::rdbg">rdbg</a></div><div class="desc docblock-short">Print to RTT and return the value of a given expression for quick debugging. This is equivalent
to Rust’s <code>std::dbg!()</code> macro.</div></li><li><div class="item-name"><a class="macro" href="macro.rprint.html" title="macro rtt_target::rprint">rprint</a></div><div class="desc docblock-short">Prints to the print RTT channel. Works just like the standard <code>print</code>.</div></li><li><div class="item-name"><a class="macro" href="macro.rprintln.html" title="macro rtt_target::rprintln">rprintln</a></div><div class="desc docblock-short">Prints to the print RTT channel, with a newline. Works just like the standard <code>println</code>.</div></li><li><div class="item-name"><a class="macro" href="macro.rtt_init.html" title="macro rtt_target::rtt_init">rtt_<wbr>init</a></div><div class="desc docblock-short">Initializes RTT with the specified channels. Channel numbers, buffer sizes and names can be
defined.</div></li><li><div class="item-name"><a class="macro" href="macro.rtt_init_default.html" title="macro rtt_target::rtt_init_default">rtt_<wbr>init_<wbr>default</a></div><div class="desc docblock-short">Initializes RTT with default up/down channels.</div></li><li><div class="item-name"><a class="macro" href="macro.rtt_init_print.html" title="macro rtt_target::rtt_init_print">rtt_<wbr>init_<wbr>print</a></div><div class="desc docblock-short">Initializes RTT with a single up channel and sets it as the print channel for the printing
macros.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.DownChannel.html" title="struct rtt_target::DownChannel">Down<wbr>Channel</a></div><div class="desc docblock-short">RTT down (host to target) channel</div></li><li><div class="item-name"><a class="struct" href="struct.TerminalChannel.html" title="struct rtt_target::TerminalChannel">Terminal<wbr>Channel</a></div><div class="desc docblock-short">An up channel that supports writing into multiple virtual terminals within the same buffer.</div></li><li><div class="item-name"><a class="struct" href="struct.TerminalWriter.html" title="struct rtt_target::TerminalWriter">Terminal<wbr>Writer</a></div><div class="desc docblock-short">Formatted writing operation. Don’t store an instance of this, but rather create a new one for
every write.</div></li><li><div class="item-name"><a class="struct" href="struct.UpChannel.html" title="struct rtt_target::UpChannel">UpChannel</a></div><div class="desc docblock-short">RTT up (target to host) channel</div></li><li><div class="item-name"><a class="struct" href="struct.uWriter.html" title="struct rtt_target::uWriter">uWriter</a></div><div class="desc docblock-short">Writer for ufmt. Don’t store an instance of this, but rather create a new one for every write.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.ChannelMode.html" title="enum rtt_target::ChannelMode">Channel<wbr>Mode</a></div><div class="desc docblock-short">Specifies what to do when a channel doesn’t have enough buffer space for a complete write.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.set_print_channel.html" title="fn rtt_target::set_print_channel">set_<wbr>print_<wbr>channel</a></div><div class="desc docblock-short">Sets the channel to use for [<code>rprint</code>], [<code>rprintln</code>], [<code>debug_rptint</code>] and [<code>debug_rprintln</code>].</div></li></ul></section></div></main></body></html>